<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Base Unlimited (Mobile)</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <!-- Added Google Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Roboto', sans-serif;
    }

    canvas {
      display: block;
    }

    #restartButton, #leaderboardButton {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 20px;
      background-color: #333;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      display: none;
      font-family: 'Roboto', sans-serif;
    }

    #restartButton {
      top: 45%;
    }

    #leaderboardButton {
      top: 55%;
    }

    #leaderboardContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.95);
      display: none;
      z-index: 1000;
    }

    #leaderboardContent {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      max-height: 80%;
      overflow-y: auto;
      background-color: #fff;
      border: 1px solid #333;
      border-radius: 5px;
      padding: 20px;
    }

    #leaderboardTable {
      width: 100%;
      border-collapse: collapse;
      font-family: 'Roboto', sans-serif;
    }

    #leaderboardTable th, #leaderboardTable td {
      border: 1px solid #333;
      padding: 8px;
      text-align: center;
    }

    #leaderboardTable th {
      background-color: #333;
      color: #fff;
      position: sticky;
      top: 0;
    }

    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #333;
      padding: 10px;
      font-size: 20px;
      border-radius: 5px;
      font-family: 'Roboto', sans-serif;
      font-weight: bold;
      background-color: rgba(255, 255, 255, 0.8);
      pointer-events: none;
    }

    #infoContent {
      pointer-events: auto;
    }

    #info button {
      pointer-events: auto;
    }

    #toggleInfoButton {
      background-color: #333;
      color: #fff;
      border: none;
      border-radius: 5px;
      padding: 5px 10px;
      cursor: pointer;
      font-family: 'Roboto', sans-serif;
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 10px;
    }

    #toggleInfoButton:hover {
      background-color: #444;
    }

    #info p {
      margin: 5px 0;
    }

    #soundButton, #settingsButton {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: transparent;
      border: none;
      cursor: pointer;
      font-size: 30px;
      color: #333;
      z-index: 1000;
    }

    #settingsButton {
      right: 50px;
    }

    #soundButton:hover, #settingsButton:hover {
      color: #555;
    }

    #closeLeaderboardButton {
      position: absolute;
      top: 20px;
      right: 30px;
      background-color: #333;
      color: #fff;
      border: none;
      border-radius: 5px;
      padding: 5px 10px;
      cursor: pointer;
      font-family: 'Roboto', sans-serif;
      font-weight: bold;
      font-size: 16px;
    }

    #closeLeaderboardButton:hover {
      background-color: #444;
    }

    #settingsModal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      display: none;
      z-index: 2000;
    }

    #settingsModal h2 {
      margin-top: 0;
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
      margin: 10px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 26px; width: 26px;
      left: 4px; bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: #2196F3;
    }

    input:focus + .slider {
      box-shadow: 0 0 1px #2196F3;
    }

    input:checked + .slider:before {
      transform: translateX(26px);
    }

    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      z-index: 1500;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <!-- Changed Icons: Using Google Material Icons -->
  <button id="soundButton"><span class="material-icons">volume_up</span></button>
  <button id="settingsButton"><span class="material-icons">settings</span></button>
  <div id="info">
    <button id="toggleInfoButton">▲ Ocultar Info</button>
    <div id="infoContent">
      <p>Tempo de jogo: <span id="tempo">0</span> s</p>
      <p>Bolas estouradas: <span id="bolasEstouradas">0</span></p>
      <p>Pontuação: <span id="pontuacao">0</span></p>
      <p>Frequência atual: <span id="spawnInterval">3000</span> ms</p>
    </div>
  </div>
  <button id="restartButton">Reiniciar</button>
  <button id="leaderboardButton">Placares</button>
  <div id="leaderboardContainer">
    <button id="closeLeaderboardButton">Fechar</button>
    <div id="leaderboardContent">
      <table id="leaderboardTable">
        <thead>
          <tr>
            <th>Posição</th>
            <th>Nome</th>
            <th>Pontuação</th>
            <th>Tempo (s)</th>
            <th>Bolas</th>
          </tr>
        </thead>
        <tbody id="leaderboardBody">
        </tbody>
      </table>
    </div>
  </div>
  <div id="overlay"></div>
  <div id="settingsModal">
    <h2>Configurações</h2>
    <label class="switch">
      <input type="checkbox" id="darkModeToggle">
      <span class="slider"></span>
    </label>
    <span>Escuro</span>
    <br>
    <label class="switch">
      <input type="checkbox" id="hardModeToggle">
      <span class="slider"></span>
    </label>
    <span>Difícil</span>
    <br>
    <button id="closeSettingsButton">Fechar</button>
  </div>
  <script>
    const baseSize = 65;
    let powerUpIndicatorSize = 10; 
    let isDarkMode = false;
    let isHardMode = false;
    let isPaused = false;
    let storedPowerUp = null;

    let leaderboardNormal = [
      { name: 'PedroFavorito', score: 7230, time: 451, ballsPopped: 400 },
      { name: 'SofyDry', score: 3815, time: 300, ballsPopped: 213 },
      { name: 'SasagamerOFC', score: 2960, time: 260, ballsPopped: 158 },
      { name: 'MateusCity', score: 1905, time: 207, ballsPopped: 109 },
      { name: 'Josi', score: 1555, time: 178, ballsPopped: 91 },
    ];

    let leaderboardHard = [
      { name: 'HardPlayer1', score: 5000, time: 160, ballsPopped: 100 },
      { name: 'HardPlayer2', score: 3200, time: 100, ballsPopped: 65 },
      { name: 'HardPlayer3', score: 2600, time: 80, ballsPopped: 50 },
    ];

    let leaderboard;

    const circleConfigNormal = [
      {
        color: 'green',
        size: 25,
        speed: 0.15,
        transparency: 1,
        clicks: () => Math.floor(Math.random() * 2) + 1,
        points: 10,
        chance: 0.2,
        time: 0,
        pitchRange: [0.9, 1.1],
      },
      {
        color: 'pink',
        size: 40,
        speed: 0.125,
        transparency: 1,
        clicks: 4,
        points: 20,
        chance: 0.15,
        time: 75,
        pitchRange: [0.9, 1.1],
      },
      {
        color: 'yellow',
        size: 35,
        speed: 0.1,
        transparency: 1,
        clicks: () => Math.floor(Math.random() * 3) + 3,
        points: 20,
        chance: 0.1,
        time: 40,
        pitchRange: [0.95, 1.15],
      },
      {
        color: 'orange',
        size: 45,
        speed: 0.075,
        transparency: 1,
        clicks: () => Math.floor(Math.random() * 5) + 8,
        points: 20,
        chance: 0.15,
        time: 75,
        pitchRange: [0.85, 1.05],
      },
      {
        color: 'red',
        size: 55,
        speed: 0.05,
        transparency: 1,
        clicks: 20,
        points: 20,
        chance: 0.15,
        time: 120,
        pitchRange: [0.8, 1.0],
      },
      {
        color: 'purple',
        size: 20,
        speed: 0.24,
        transparency: 1,
        clicks: 1,
        points: 20,
        chance: 0.15,
        time: 20,
        pitchRange: [1.1, 1.3],
      },
      {
        color: 'cyan',
        size: 18,
        speed: 0.275,
        transparency: 1,
        clicks: 2,
        points: 20,
        chance: 0.15,
        time: 90,
        pitchRange: [1.15, 1.35],
      },
      {
        color: 'lightpink',
        size: 20,
        speed: 0.26,
        transparency: 1,
        clicks: 1,
        points: 15,
        chance: 0,
        time: 5000,
        pitchRange: [1.1, 1.3],
      },
      {
        color: 'lightblue',
        size: 30,
        speed: 0.17,
        transparency: 0,
        clicks: 2,
        points: 15,
        chance: 0.3,
        time: 160,
        minTransparency: 0,
        maxTransparency: 1,
        transparencyDistance: 200,
        pitchRange: [0.95, 1.15],
      },
      {
        color: 'blue',
        size: 40,
        speed: 0.15,
        transparency: 1,
        clicks: 3,
        points: 30,
        chance: 0.2,
        time: 120,
        speedIncrements: [0.15, 0.2, 0.3],
        sizeDecrements: [6, 6, 6],
        minSize: 15,
        defaultSpeedIncrement: 0.1,
        defaultSizeDecrement: 7,
        pitchRange: [0.85, 1.05],
      },
      {
        color: 'brown',
        size: 35,
        speed: 0.12,
        transparency: 1,
        clicks: () => Math.floor(Math.random() * 3) + 2,
        points: 25,
        chance: 0.1,
        time: 180,
        stainDuration: 10,
        stainFadeStart: 7,
        stainMaxCount: 3,
        numberOfStains: 2,
        pitchRange: [0.8, 1.0],
      },
    ];

    const circleConfigHard = [
      {
        color: 'green',
        size: 25,
        speed: 0.17,
        transparency: 1,
        clicks: 3,
        points: 10,
        chance: 0.2,
        time: 0,
        pitchRange: [0.9, 1.1],
      },
      {
        color: 'pink',
        size: 40,
        speed: 0.135,
        transparency: 1,
        clicks: 6,
        points: 20,
        chance: 0.15,
        time: 35,
        pitchRange: [0.7, 0.9],
      },
      {
        color: 'yellow',
        size: 35,
        speed: 0.12,
        transparency: 1,
        clicks: 5,
        points: 20,
        chance: 0.1,
        time: 0,
        pitchRange: [0.7, 0.9],
      },
      {
        color: 'orange',
        size: 45,
        speed: 0.085,
        transparency: 1,
        clicks: 12,
        points: 20,
        chance: 0.15,
        time: 15,
        pitchRange: [0.5, 0.7],
      },
      {
        color: 'red',
        size: 55,
        speed: 0.07,
        transparency: 1,
        clicks: 20,
        points: 20,
        chance: 0.15,
        time: 45,
        pitchRange: [0.3, 0.5],
      },
      {
        color: 'purple',
        size: 20,
        speed: 0.26,
        transparency: 1,
        clicks: 1,
        points: 20,
        chance: 0.15,
        time: 20,
        pitchRange: [1.2, 1.4],
      },
      {
        color: 'cyan',
        size: 18,
        speed: 0.29,
        transparency: 1,
        clicks: 2,
        points: 20,
        chance: 0.15,
        time: 60,
        pitchRange: [1.4, 1.6],
      },
      {
        color: 'lightpink',
        size: 20,
        speed: 0.32,
        transparency: 1,
        clicks: 2,
        points: 15,
        chance: 0,
        time: 5000,
        pitchRange: [1.3, 1.5],
      },
      {
        color: 'lightblue',
        size: 30,
        speed: 0.2,
        transparency: 0,
        clicks: 2,
        points: 15,
        chance: 0.3,
        time: 0,
        minTransparency: 0,
        maxTransparency: 1,
        transparencyDistance: 200,
        pitchRange: [0.9, 1.1],
      },
      {
        color: 'blue',
        size: 40,
        speed: 0.15,
        transparency: 1,
        clicks: 3,
        points: 30,
        chance: 0.4,
        time: 45,
        speedIncrements: [0.15, 0.3, 0.7],
        sizeDecrements: [10, 11, 12],
        minSize: 7,
        defaultSpeedIncrement: 0.1,
        defaultSizeDecrement: 8,
        pitchRange: [0.7, 0.9],
      },
      {
        color: 'brown',
        size: 35,
        speed: 0.15,
        transparency: 1,
        clicks: () => Math.floor(Math.random() * 3) + 3,
        points: 25,
        chance: 0.15,
        time: 100,
        stainDuration: 12,
        stainFadeStart: 8,
        stainMaxCount: 5,
        numberOfStains: 3,
        pitchRange: [0.7, 0.9],
      },
    ];

    const colorGradients = {
      'red': ['darkred', 'red'],
      'green': ['darkgreen', 'green'],
      'blue': ['darkblue', 'blue'],
      'yellow': ['goldenrod', 'yellow'],
      'orange': ['darkorange', 'orange'],
      'purple': ['indigo', 'purple'],
      'pink': ['deeppink', 'pink'],
      'cyan': ['teal', 'cyan'],
      'lightpink': ['hotpink', 'lightpink'],
      'lightblue': ['dodgerblue', 'lightblue'],
      'black': ['black', 'gray'],
      'gray': ['dimgray', 'lightgray'],
      'brown': ['saddlebrown', 'brown']
    };

    const difficultyLevelsNormal = [
      { time: 0, interval: 3000, circlesAtOnce: 1 },
      { time: 20, interval: 2800, circlesAtOnce: 1 },
      { time: 40, interval: 2600, circlesAtOnce: 1 },
      { time: 60, interval: 2400, circlesAtOnce: 1 },
      { time: 80, interval: 2200, circlesAtOnce: 1 },
      { time: 140, interval: 3000, circlesAtOnce: 2 },
      { time: 170, interval: 2700, circlesAtOnce: 2 },
      { time: 210, interval: 2400, circlesAtOnce: 2 },
      { time: 265, interval: 2400, circlesAtOnce: 0 },
      { time: 270, interval: 3000, circlesAtOnce: 3 },
      { time: 310, interval: 2850, circlesAtOnce: 3 },
      { time: 350, interval: 2700, circlesAtOnce: 3 },
      { time: 430, interval: 2400, circlesAtOnce: 3 },
    ];

    const difficultyLevelsHard = [
      { time: 0, interval: 2500, circlesAtOnce: 2 },
      { time: 30, interval: 2200, circlesAtOnce: 2 },
      { time: 60, interval: 1900, circlesAtOnce: 2 },
      { time: 100, interval: 2700, circlesAtOnce: 3 },
      { time: 150, interval: 2500, circlesAtOnce: 3 },
      { time: 195, interval: 2500, circlesAtOnce: 0 },
      { time: 200, interval: 3300, circlesAtOnce: 4 },
      { time: 230, interval: 3000, circlesAtOnce: 4 }
    ];

    const powerUpConfigNormal = {
      starInterval: 80,
      starDuration: 8,
      powerUpDuration: 12,
      redPentagon: {
        size: 200,
        transparency: 0.30,
      },
      bluePentagon: {
        size: 200,
        transparency: 0.30,
      },
    };

    const powerUpConfigHard = {
      starInterval: 60,
      starDuration: 5,
      powerUpDuration: 8,
      redPentagon: {
        size: 200,
        transparency: 0.3,
      },
      bluePentagon: {
        size: 200,
        transparency: 0.3,
      },
    };

    const grayCircleConfigNormal = {
      color: 'gray',
      size: 40,
      initialSpeed: 0.22,
      maxSpeed: 0.44,
      speedIncrement: 0.008,
      transparency: 1,
      isGrayCircle: true,
      pushBackDistance: 60,
      time: 0,
    };

    const grayCircleConfigHard = {
      color: 'gray',
      size: 45,
      initialSpeed: 0.15,
      maxSpeed: 0.6,
      speedIncrement: 0.06,
      transparency: 1,
      isGrayCircle: true,
      pushBackDistance: 35,
      time: 0,
    };

    const blackCircleConfigNormal = {
      color: 'black',
      size: 30,
      initialSpeed: 0.2,
      maxSpeed: 0.6,
      speedIncrement: 0.08,
      transparency: 1,
      isBlackCircle: true,
      pushBackDistance: 25,
      minSize: 30,
      maxSize: 100,
      sizeGrowth: {
        'green': 2,
        'pink': 3,
        'yellow': 4,
        'orange': 5,
        'red': 6,
        'purple': 1,
        'cyan': 1,
        'lightpink': 2,
        'lightblue': 2,
        'blue': 4,
        'brown':4
      },
      time: 150,
    };

    const blackCircleConfigHard = {
      color: 'black',
      size: 35,
      initialSpeed: 0.3,
      maxSpeed: 0.65,
      speedIncrement: 0.02,
      transparency: 1,
      isBlackCircle: true,
      pushBackDistance: 60,
      minSize: 35,
      maxSize: 80,
      sizeGrowth: {
        'green': 1,
        'pink': 2,
        'yellow': 1.5,
        'orange': 2.5,
        'red': 4,
        'purple': 1,
        'cyan': 1,
        'lightpink': 1,
        'lightblue': 1.75,
        'blue': 1.5,
        'brown':2.5
      },
      time: 0,
    };

    const grayCircleTimesNormal = [400, 500, 600];
    const blackCircleTimesNormal = [0, 0, 0];
    const grayCircleTimesHard = [0, 0, 0];
    const blackCircleTimesHard = [150, 210, 270];

    const speedIncreaseConfigNormal = {
      startTime: 480,
      incrementPerSecond: 0.001,
    };

    const speedIncreaseConfigHard = {
      startTime: 260,
      incrementPerSecond: 0.001,
    };

    let grayCircleTimes;
    let blackCircleTimes;
    let speedIncreaseConfig;
    let accumulatedSpeedIncrease = 0;

    let circleConfig;
    let difficultyLevels;
    let powerUpConfig;
    let grayCircleConfig;
    let blackCircleConfig;

    let activeRedPowerUp = false;
    let activeBluePowerUp = false;
    let redPowerUpTimeLeft = 0;
    let bluePowerUpTimeLeft = 0;
    let activeOrangePowerUp = false;
    let orangeWaveActive = false;
    let orangeWaveMaxSize = 300; 
    let orangeWaveDamage = 5;
    let orangeHitCircles = [];
    let orangeWaveStartTime = 0;
    let orangeWaveDuration = 3000;
    let orangeWaveIntervalId = null;

    let redPowerUpIntervalId = null;

    let circles = [];
    let stars = [];
    let particles = [];
    let stains = [];
    let score = 0;
    let ballsPopped = 0;
    let gameTime = 0;
    let isGameOver = false;

    let currentSpawnInterval;
    let currentCirclesAtOnce;
    let spawnIntervalId;
    let starSpawnIntervalId;

    const popSoundVolume = 0.3;
    const gameOverSoundVolume = 0.5;
    const restartSoundVolume = 0.5;
    const clickSoundVolume = 0.4;
    const powerUpSoundVolume = 0.5;
    const stainSoundVolume = 0.5;
    let isMuted = false;

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const restartButton = document.getElementById('restartButton');
    const leaderboardButton = document.getElementById('leaderboardButton');
    const closeLeaderboardButton = document.getElementById('closeLeaderboardButton');
    const tempoElement = document.getElementById('tempo');
    const bolasEstouradasElement = document.getElementById('bolasEstouradas');
    const pontuacaoElement = document.getElementById('pontuacao');
    const spawnIntervalElement = document.getElementById('spawnInterval');
    const soundButton = document.getElementById('soundButton');
    const settingsButton = document.getElementById('settingsButton');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const hardModeToggle = document.getElementById('hardModeToggle');
    const settingsModal = document.getElementById('settingsModal');
    const closeSettingsButton = document.getElementById('closeSettingsButton');
    const overlay = document.getElementById('overlay');
    const leaderboardContainer = document.getElementById('leaderboardContainer');
    const leaderboardBody = document.getElementById('leaderboardBody');
    const toggleInfoButton = document.getElementById('toggleInfoButton');
    const infoContent = document.getElementById('infoContent');
    const infoElement = document.getElementById('info');

    canvas.addEventListener('touchstart', function(e) {
      e.preventDefault();
    }, { passive: false });

    const pentagon = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: baseSize,
      draw() {
        ctx.save();
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        const gradient = ctx.createLinearGradient(this.x - this.size, this.y - this.size, this.x + this.size, this.y + this.size);
        const colors = colorGradients['brown'] || ['brown', 'brown'];
        gradient.addColorStop(0, colors[0]);
        gradient.addColorStop(1, colors[1]);

        ctx.beginPath();
        const angle = (2 * Math.PI) / 5;
        for (let i = 0; i < 5; i++) {
          const px = this.x + this.size * Math.cos(i * angle - Math.PI / 2);
          const py = this.y + this.size * Math.sin(i * angle - Math.PI / 2);
          i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();

        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#fff';
        ctx.font = '20px Roboto';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Base', this.x, this.y);

        let powerUpColor = 'gray';
        if (storedPowerUp === 'red') powerUpColor = 'red';
        else if (storedPowerUp === 'blue') powerUpColor = 'blue';
        else if (storedPowerUp === 'orange') powerUpColor = 'orange';

        const indicatorY = this.y + 20;
        const indicatorGradient = ctx.createLinearGradient(this.x - powerUpIndicatorSize, indicatorY - powerUpIndicatorSize, this.x + powerUpIndicatorSize, indicatorY + powerUpIndicatorSize);
        const indicatorColors = colorGradients[powerUpColor] || [powerUpColor, powerUpColor];
        indicatorGradient.addColorStop(0, indicatorColors[0]);
        indicatorGradient.addColorStop(1, indicatorColors[1]);

        ctx.beginPath();
        ctx.arc(this.x, indicatorY, powerUpIndicatorSize, 0, Math.PI * 2);
        ctx.fillStyle = indicatorGradient;
        ctx.fill();

        ctx.restore();
      },
    };

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      pentagon.x = canvas.width / 2;
      pentagon.y = canvas.height / 2;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function playPopSound(pitchRange = [1.0, 1.0]) {
      if (isMuted) return;
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.type = 'sine';
      const baseFrequency = 600;
      const randomPitch = Math.random() * (pitchRange[1] - pitchRange[0]) + pitchRange[0];
      oscillator.frequency.setValueAtTime(baseFrequency * randomPitch, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(popSoundVolume, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.15);
    }

    function playClickSound() {
      if (isMuted) return;
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(clickSoundVolume, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.1);
    }

    function playPowerUpSound() {
      if (isMuted) return;
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.type = 'triangle';
      oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(powerUpSoundVolume, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.3);
    }

    function playRestartSound() {
      if (isMuted) return;
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.type = 'triangle';
      oscillator.frequency.setValueAtTime(500, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(restartSoundVolume, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.5);
    }

    function playGameOverSound() {
      if (isMuted) return;
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.type = 'square';
      oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(gameOverSoundVolume, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1);
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 1);
    }

    function playStainSound() {
      if (isMuted) return;
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.type = 'sawtooth';
      oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(stainSoundVolume, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.5);
    }

    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 5 + 2;
        this.speedX = (Math.random() - 0.5) * 4;
        this.speedY = (Math.random() - 0.5) * 4;
        this.color = color;
        this.life = 30;
        this.opacity = 1;
      }
      update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life--;
        this.opacity = this.life / 30;
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    class Stain {
      constructor(color, maxStains, duration, fadeStart) {
        this.color = color;
        this.opacity = 1;
        this.life = 0;
        this.maxLife = duration * 60;
        this.fadeStart = fadeStart * 60;
        this.maxStains = maxStains;
        this.radius = 150;
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
      }
      update() {
        this.life++;
        if (this.life > this.fadeStart) {
          this.opacity = 1 - (this.life - this.fadeStart) / (this.maxLife - this.fadeStart);
        }
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity * 0.7;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      isExpired() {
        return this.life >= this.maxLife;
      }
    }

    class Circle {
      constructor(config, x = null, y = null) {
        this.x = x !== null ? x : Math.random() > 0.5 ? 0 : canvas.width;
        this.y = y !== null ? y : Math.random() * canvas.height;
        this.color = config.color;
        this.size = config.size;
        this.transparency = config.transparency;
        this.clicks = typeof config.clicks === "function" ? config.clicks() : config.clicks;
        this.points = config.points;
        this.time = config.time;
        this.hasBeenSlowed = false;
        this.lastRedClickTime = 0;
        this.initialClicks = this.clicks;
        this.isGrayCircle = config.isGrayCircle || false;
        this.isBlackCircle = config.isBlackCircle || false;
        this.pushBackDistance = config.pushBackDistance || 0;
        this.pitchRange = config.pitchRange || [1.0, 1.0];

        if (this.isBlackCircle) {
          this.minSize = config.minSize;
          this.maxSize = config.maxSize;
          this.sizeGrowth = config.sizeGrowth;
        }

        if (this.color === 'blue') {
          this.speedIncrements = config.speedIncrements || [];
          this.sizeDecrements = config.sizeDecrements || [];
          this.defaultSpeedIncrement = config.defaultSpeedIncrement || 0.1;
          this.defaultSizeDecrement = config.defaultSizeDecrement || 5;
          this.minSize = config.minSize || 10;
        }

        if (this.color === 'lightblue' || this.color === 'darkblue') {
          this.minTransparency = config.minTransparency || 0;
          this.maxTransparency = config.maxTransparency || 1;
          this.transparencyDistance = config.transparencyDistance || 100;
        }

        if (this.color === 'brown') {
          this.stainDuration = config.stainDuration || 10;
          this.stainFadeStart = config.stainFadeStart || 7;
          this.stainMaxCount = config.stainMaxCount || 3;
          this.numberOfStains = config.numberOfStains || 1;
        }

        if (this.isGrayCircle || this.isBlackCircle) {
          this.speed = config.initialSpeed;
          this.maxSpeed = config.maxSpeed;
          this.speedIncrement = config.speedIncrement;
          const distanceToPentagon = Math.hypot(pentagon.x - this.x, pentagon.y - this.y);
          this.dx = (pentagon.x - this.x) / distanceToPentagon;
          this.dy = (pentagon.y - this.y) / distanceToPentagon;
        } else {
          this.speed = config.speed;
          this.dx = (pentagon.x - this.x) / 100;
          this.dy = (pentagon.y - this.y) / 100;
        }
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = this.transparency;
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        const gradient = ctx.createLinearGradient(this.x - this.size, this.y - this.size, this.x + this.size, this.y + this.size);
        const colors = colorGradients[this.color] || [this.color, this.color];
        gradient.addColorStop(0, colors[0]);
        gradient.addColorStop(1, colors[1]);

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;

        ctx.font = 'bold 18px Roboto';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        if (!this.isGrayCircle && !this.isBlackCircle && this.clicks > 0) {
          ctx.fillStyle = '#fff';
          ctx.fillText(this.clicks, this.x, this.y);
        }

        ctx.restore();
      }
      update() {
        if (gameTime >= speedIncreaseConfig.startTime) {
          this.speed += speedIncreaseConfig.incrementPerSecond / 60;
        }
        if (!this.isGrayCircle && !this.isBlackCircle && activeBluePowerUp && this.isInsideBluePentagon() && !this.hasBeenSlowed) {
          this.speed *= 0.5;
          this.hasBeenSlowed = true;
        }

        this.x += this.dx * this.speed;
        this.y += this.dy * this.speed;

        if (this.color === 'lightblue') {
          const distToBase = Math.hypot(this.x - pentagon.x, this.y - pentagon.y);
          if (distToBase <= this.transparencyDistance) {
            const transparencyProgress = Math.min((this.transparencyDistance - distToBase) / this.transparencyDistance, 1);
            this.transparency = this.minTransparency + (this.maxTransparency - this.minTransparency) * transparencyProgress;
          } else {
            this.transparency = this.minTransparency;
          }
        }

        if (this.isBlackCircle) {
          circles.forEach((otherCircle) => {
            if (otherCircle !== this && !otherCircle.isBlackCircle && !otherCircle.isGrayCircle) {
              const dist = Math.hypot(this.x - otherCircle.x, this.y - otherCircle.y);
              if (dist < this.size + otherCircle.size && this.size < this.maxSize) {
                this.grow(otherCircle);
                otherCircle.destroy();
              }
            }
          });
        }

        if (this.checkCollision()) {
          if (this.color === 'brown') {
            this.createStains();
            this.destroy();
          } else {
            gameOver();
          }
        }
      }
      checkCollision() {
        const dist = Math.hypot(this.x - pentagon.x, this.y - pentagon.y);
        return dist < this.size + pentagon.size;
      }
      handleClick() {
        if (this.isGrayCircle || this.isBlackCircle) {
          const angle = Math.atan2(pentagon.y - this.y, pentagon.x - this.x);
          this.x -= Math.cos(angle) * this.pushBackDistance;
          this.y -= Math.sin(angle) * this.pushBackDistance;
          this.speed += this.speedIncrement;
          if (this.speed > this.maxSpeed) {
            this.speed = this.maxSpeed;
          }
          const distanceToPentagon = Math.hypot(pentagon.x - this.x, pentagon.y - this.y);
          this.dx = (pentagon.x - this.x) / distanceToPentagon;
          this.dy = (pentagon.y - this.y) / distanceToPentagon;
          playClickSound();
        } else {
          if (this.color === 'blue') {
            const clicksDone = this.initialClicks - this.clicks;
            if (Array.isArray(this.speedIncrements) && clicksDone < this.speedIncrements.length) {
              this.speed += this.speedIncrements[clicksDone];
            } else {
              this.speed += this.defaultSpeedIncrement;
            }
            this.speed += accumulatedSpeedIncrease;
            if (Array.isArray(this.sizeDecrements) && clicksDone < this.sizeDecrements.length) {
              this.size -= this.sizeDecrements[clicksDone];
            } else {
              this.size -= this.defaultSizeDecrement;
            }
            if (this.size < this.minSize) {
              this.size = this.minSize;
            }
          }

          this.clicks -= 1;
          if (this.clicks <= 0) {
            if (this.color === 'pink') {
              spawnAdjacentCircles(this);
            }
            this.destroy();
          }
        }
      }
      grow(otherCircle) {
        const growth = blackCircleConfig.sizeGrowth[otherCircle.color] || 1;
        this.size += growth;
        if (this.size > this.maxSize) {
          this.size = this.maxSize;
        }
      }
      destroy() {
        if (!this.isGrayCircle && !this.isBlackCircle) {
          score += this.points;
          ballsPopped += 1;
          playPopSound(this.pitchRange);
          circles = circles.filter((circle) => circle !== this);
          for (let i = 0; i < 15; i++) {
            particles.push(new Particle(this.x, this.y, this.color));
          }
        }
      }
      createStains() {
        playStainSound();
        const canSpawn = this.stainMaxCount - stains.length;
        const toSpawn = Math.min(this.numberOfStains, canSpawn);
        for (let i = 0; i < toSpawn; i++) {
          stains.push(new Stain('brown', this.stainMaxCount, this.stainDuration, this.stainFadeStart));
        }
      }
      isInsideRedPentagon() {
        const dist = Math.hypot(this.x - pentagon.x, this.y - pentagon.y);
        return dist < powerUpConfig.redPentagon.size;
      }
      isInsideBluePentagon() {
        const dist = Math.hypot(this.x - pentagon.x, this.y - pentagon.y);
        return dist < powerUpConfig.bluePentagon.size;
      }
    }

    class Star {
      constructor(color) {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = 30;
        this.color = color;
        this.spawnTime = gameTime;
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const sx = this.x + this.size * Math.cos((Math.PI * 2 * i) / 5 - Math.PI / 2);
          const sy = this.y + this.size * Math.sin((Math.PI * 2 * i) / 5 - Math.PI / 2);
          i === 0 ? ctx.moveTo(sx, sy) : ctx.lineTo(sx, sy);
        }
        ctx.closePath();
        ctx.fill();
      }
      handleClick() {
        playPowerUpSound();
        if (this.color === 'red') {
          storedPowerUp = 'red';
        } else if (this.color === 'blue') {
          storedPowerUp = 'blue';
        } else if (this.color === 'orange') {
          storedPowerUp = 'orange';
        }
        stars = stars.filter((star) => star !== this);
      }
    }

    function initializeConfigurations() {
      if (isHardMode) {
        circleConfig = circleConfigHard;
        difficultyLevels = difficultyLevelsHard;
        powerUpConfig = powerUpConfigHard;
        leaderboard = leaderboardHard;
        grayCircleConfig = grayCircleConfigHard;
        blackCircleConfig = blackCircleConfigHard;
        grayCircleTimes = [...grayCircleTimesHard];
        blackCircleTimes = [...blackCircleTimesHard];
        speedIncreaseConfig = speedIncreaseConfigHard;
      } else {
        circleConfig = circleConfigNormal;
        difficultyLevels = difficultyLevelsNormal;
        powerUpConfig = powerUpConfigNormal;
        leaderboard = leaderboardNormal;
        grayCircleConfig = grayCircleConfigNormal;
        blackCircleConfig = blackCircleConfigNormal;
        grayCircleTimes = [...grayCircleTimesNormal];
        blackCircleTimes = [...blackCircleTimesNormal];
        speedIncreaseConfig = speedIncreaseConfigNormal;
      }
      accumulatedSpeedIncrease = 0;
    }

    initializeConfigurations();

    function activateRedPowerUp() {
      activeRedPowerUp = true;
      redPowerUpTimeLeft = powerUpConfig.powerUpDuration;
    }

    function activateBluePowerUp() {
      activeBluePowerUp = true;
      bluePowerUpTimeLeft = powerUpConfig.powerUpDuration;
    }

    function activateOrangePowerUp() {
      activeOrangePowerUp = true;
      orangeWaveActive = true;
      orangeHitCircles = [];
      orangeWaveStartTime = performance.now();

      if (orangeWaveIntervalId === null) {
        orangeWaveIntervalId = setInterval(() => {
          if (!orangeWaveActive) {
            clearInterval(orangeWaveIntervalId);
            orangeWaveIntervalId = null;
          } else {
            updateOrangeWave();
          }
        }, 200);
      }
    }

    function spawnCircles() {
      if (isGameOver || isPaused) return;
      const eligibleConfigs = circleConfig.filter((config) => gameTime >= config.time);
      if (eligibleConfigs.length === 0) return;
      let redCirclesCount = circles.filter(circle => circle.color === 'red').length;
      let redCirclesToAdd = Math.max(0, 2 - redCirclesCount);
      for (let i = 0; i < currentCirclesAtOnce; i++) {
        let availableConfigs = eligibleConfigs.slice();
        if (redCirclesToAdd <= 0) {
          availableConfigs = availableConfigs.filter(cfg => cfg.color !== 'red');
        }
        if (availableConfigs.length === 0) break;
        const randomIndex = Math.floor(Math.random() * availableConfigs.length);
        const config = availableConfigs[randomIndex];
        const adjustedConfig = { ...config };
        adjustedConfig.speed += accumulatedSpeedIncrease;
        if (config.color === 'red') {
          if (redCirclesToAdd > 0) {
            redCirclesToAdd--;
            redCirclesCount++;
            circles.push(new Circle(adjustedConfig));
          } else {
            availableConfigs.splice(randomIndex, 1);
            i--;
            continue;
          }
        } else {
          circles.push(new Circle(adjustedConfig));
        }
      }
    }

    function spawnGrayCircle() {
      if (isGameOver || isPaused) return;
      const grayCircle = new Circle({ ...grayCircleConfig, isGrayCircle: true });
      circles.push(grayCircle);
    }

    function spawnBlackCircle() {
      if (isGameOver || isPaused) return;
      const blackCircle = new Circle({ ...blackCircleConfig, isBlackCircle: true });
      circles.push(blackCircle);
    }

    function spawnAdjacentCircles(originalCircle) {
      const lightPinkConfig = circleConfig.find((c) => c.color === 'lightpink');
      if (!lightPinkConfig) return;
      const offsets = [-30, 30];
      offsets.forEach((offset) => {
        const newCircle = new Circle(lightPinkConfig, originalCircle.x + offset, originalCircle.y);
        circles.push(newCircle);
      });
    }

    function spawnStar() {
      if (isGameOver || isPaused || stars.length > 0) return;
      const r = Math.random();
      let color;
      if (r < 0.33) {
        color = 'red';
      } else if (r < 0.66) {
        color = 'blue';
      } else {
        color = 'orange';
      }
      stars.push(new Star(color));
      setTimeout(() => {
        stars = stars.filter((star) => star.color !== color);
      }, powerUpConfig.starDuration * 1000);
    }

    function updatePowerUps() {
      if (isPaused) return;
      if (activeRedPowerUp) {
        redPowerUpTimeLeft -= 1;
        if (redPowerUpTimeLeft <= 0) {
          activeRedPowerUp = false;
        }
      }
      if (activeBluePowerUp) {
        bluePowerUpTimeLeft -= 1;
        if (bluePowerUpTimeLeft <= 0) {
          activeBluePowerUp = false;
        }
      }
    }

    function updateDifficulty() {
      const applicableLevels = difficultyLevels.filter((level) => gameTime >= level.time);
      const currentLevel = applicableLevels[applicableLevels.length - 1];
      if (currentLevel.interval !== currentSpawnInterval || currentLevel.circlesAtOnce !== currentCirclesAtOnce) {
        currentSpawnInterval = currentLevel.interval;
        currentCirclesAtOnce = currentLevel.circlesAtOnce;
        spawnIntervalElement.textContent = currentSpawnInterval.toString();
        clearInterval(spawnIntervalId);
        spawnIntervalId = setInterval(spawnCircles, currentSpawnInterval);
      }
    }

    function gameOver() {
      isGameOver = true;
      playGameOverSound();
      restartButton.style.display = 'block';
      leaderboardButton.style.display = 'block';
      clearInterval(spawnIntervalId);
      clearInterval(starSpawnIntervalId);
      updateLeaderboard();
    }

    function updateLeaderboard() {
      const existingEntryIndex = leaderboard.findIndex(player => player.name === 'Você');
      if (existingEntryIndex !== -1) {
        if (score > leaderboard[existingEntryIndex].score) {
          leaderboard[existingEntryIndex].score = score;
          leaderboard[existingEntryIndex].time = gameTime;
          leaderboard[existingEntryIndex].ballsPopped = ballsPopped;
        }
      } else {
        leaderboard.push({
          name: 'Você',
          score: score,
          time: gameTime,
          ballsPopped: ballsPopped,
        });
      }
      leaderboard.sort((a, b) => b.score - a.score);
      leaderboard = leaderboard.slice(0, 10);
      leaderboardBody.innerHTML = '';
      leaderboard.forEach((player, index) => {
        const row = document.createElement('tr');
        const positionCell = document.createElement('td');
        positionCell.textContent = index + 1;
        row.appendChild(positionCell);
        const nameCell = document.createElement('td');
        nameCell.textContent = player.name;
        row.appendChild(nameCell);
        const scoreCell = document.createElement('td');
        scoreCell.textContent = player.score;
        row.appendChild(scoreCell);
        const timeCell = document.createElement('td');
        timeCell.textContent = player.time;
        row.appendChild(timeCell);
        const ballsPoppedCell = document.createElement('td');
        ballsPoppedCell.textContent = player.ballsPopped;
        row.appendChild(ballsPoppedCell);
        leaderboardBody.appendChild(row);
      });
    }

    function restartGame() {
      isGameOver = false;
      circles = [];
      stars = [];
      particles = [];
      stains = [];
      score = 0;
      ballsPopped = 0;
      gameTime = 0;
      activeRedPowerUp = false;
      activeBluePowerUp = false;
      redPowerUpTimeLeft = 0;
      bluePowerUpTimeLeft = 0;
      activeOrangePowerUp = false;
      orangeWaveActive = false;
      storedPowerUp = null;
      tempoElement.textContent = '0';
      bolasEstouradasElement.textContent = '0';
      pontuacaoElement.textContent = '0';
      initializeConfigurations();
      const initialLevel = difficultyLevels[0];
      currentSpawnInterval = initialLevel.interval;
      currentCirclesAtOnce = initialLevel.circlesAtOnce;
      spawnIntervalElement.textContent = currentSpawnInterval.toString();
      restartButton.style.display = 'none';
      leaderboardButton.style.display = 'none';
      leaderboardContainer.style.display = 'none';
      clearInterval(spawnIntervalId);
      spawnIntervalId = setInterval(spawnCircles, currentSpawnInterval);
      clearInterval(starSpawnIntervalId);
      starSpawnIntervalId = setInterval(spawnStar, powerUpConfig.starInterval * 1000);
      isPaused = false;
      animate();
    }

    canvas.addEventListener('click', (e) => {
      if (isPaused) return;
      const rect = canvas.getBoundingClientRect();
      const offsetX = e.clientX - rect.left;
      const offsetY = e.clientY - rect.top;
      stars.forEach((star) => {
        const dist = Math.hypot(offsetX - star.x, offsetY - star.y);
        if (dist < star.size) {
          star.handleClick();
        }
      });
      circles.forEach((circle) => {
        const dist = Math.hypot(offsetX - circle.x, offsetY - circle.y);
        if (dist < circle.size) {
          circle.handleClick();
        }
      });
      const distToPentagon = Math.hypot(offsetX - pentagon.x, offsetY - pentagon.y);
      if (distToPentagon < pentagon.size) {
        if (storedPowerUp !== null) {
          if (storedPowerUp === 'red') {
            activateRedPowerUp();
          } else if (storedPowerUp === 'blue') {
            activateBluePowerUp();
          } else if (storedPowerUp === 'orange') {
            activateOrangePowerUp();
          }
          storedPowerUp = null;
        }
      }
    });

    canvas.addEventListener('touchstart', (e) => {
      if (isPaused) return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      for (let i = 0; i < e.changedTouches.length; i++) {
        const touch = e.changedTouches[i];
        const offsetX = touch.clientX - rect.left;
        const offsetY = touch.clientY - rect.top;
        stars.forEach((star) => {
          const dist = Math.hypot(offsetX - star.x, offsetY - star.y);
          if (dist < star.size) {
            star.handleClick();
          }
        });
        circles.forEach((circle) => {
          const dist = Math.hypot(offsetX - circle.x, offsetY - circle.y);
          if (dist < circle.size) {
            circle.handleClick();
          }
        });
        const distToPentagon = Math.hypot(offsetX - pentagon.x, offsetY - pentagon.y);
        if (distToPentagon < pentagon.size) {
          if (storedPowerUp !== null) {
            if (storedPowerUp === 'red') {
              activateRedPowerUp();
            } else if (storedPowerUp === 'blue') {
              activateBluePowerUp();
            } else if (storedPowerUp === 'orange') {
              activateOrangePowerUp();
            }
            storedPowerUp = null;
          }
        }
      }
    }, { passive: false });

    restartButton.addEventListener('click', restartGame);
    leaderboardButton.addEventListener('click', () => {
      restartButton.style.display = 'none';
      leaderboardButton.style.display = 'none';
      leaderboardContainer.style.display = 'block';
    });

    closeLeaderboardButton.addEventListener('click', () => {
      restartButton.style.display = 'block';
      leaderboardButton.style.display = 'block';
      leaderboardContainer.style.display = 'none';
    });

    toggleInfoButton.addEventListener('click', () => {
      if (infoContent.style.display === 'none') {
        infoContent.style.display = 'block';
        toggleInfoButton.textContent = '▲ Ocultar Info';
      } else {
        infoContent.style.display = 'none';
        toggleInfoButton.textContent = '▼ Mostrar Info';
      }
    });

    soundButton.addEventListener('click', () => {
      isMuted = !isMuted;
      soundButton.innerHTML = isMuted ? '<span class="material-icons">volume_off</span>' : '<span class="material-icons">volume_up</span>';
    });

    settingsButton.addEventListener('click', () => {
      isPaused = true;
      settingsModal.style.display = 'block';
      overlay.style.display = 'block';
    });

    closeSettingsButton.addEventListener('click', () => {
      isPaused = false;
      settingsModal.style.display = 'none';
      overlay.style.display = 'none';
      animate();
    });

    darkModeToggle.addEventListener('change', () => {
      isDarkMode = darkModeToggle.checked;
      if (isDarkMode) {
        infoElement.style.color = '#eee';
        infoElement.style.backgroundColor = 'rgba(34, 34, 34, 0.8)';
        toggleInfoButton.style.backgroundColor = '#eee';
        toggleInfoButton.style.color = '#222';
        infoContent.style.backgroundColor = 'rgba(34, 34, 34, 0.8)';
        infoContent.style.color = '#eee';
      } else {
        infoElement.style.color = '#333';
        infoElement.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        toggleInfoButton.style.backgroundColor = '#333';
        toggleInfoButton.style.color = '#fff';
        infoContent.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        infoContent.style.color = '#333';
      }
    });

    hardModeToggle.addEventListener('change', () => {
      isHardMode = hardModeToggle.checked;
      settingsModal.style.display = 'none';
      overlay.style.display = 'none';
      isPaused = false;
      restartGame();
    });

    function updateInfo() {
      if (isGameOver || isPaused) return;
      gameTime += 1;
      tempoElement.textContent = gameTime.toString();

      updateDifficulty();
      updatePowerUps();

      if (gameTime >= speedIncreaseConfig.startTime) {
        accumulatedSpeedIncrease += speedIncreaseConfig.incrementPerSecond;
      }
      if (grayCircleTimes.includes(gameTime)) {
        spawnGrayCircle();
        grayCircleTimes = grayCircleTimes.filter(time => time !== gameTime);
      }
      if (blackCircleTimes.includes(gameTime)) {
        spawnBlackCircle();
        blackCircleTimes = blackCircleTimes.filter(time => time !== gameTime);
      }
    }

    function drawPowerUpPentagons() {
      if (activeRedPowerUp) {
        ctx.save();
        ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        const gradientRed = ctx.createLinearGradient(pentagon.x - powerUpConfig.redPentagon.size, pentagon.y - powerUpConfig.redPentagon.size, pentagon.x + powerUpConfig.redPentagon.size, pentagon.y + powerUpConfig.redPentagon.size);
        gradientRed.addColorStop(0, 'darkred');
        gradientRed.addColorStop(1, 'red');
        ctx.beginPath();
        const angle = (2 * Math.PI) / 5;
        for (let i = 0; i < 5; i++) {
          const px = pentagon.x + powerUpConfig.redPentagon.size * Math.cos(i * angle - Math.PI / 2);
          const py = pentagon.y + powerUpConfig.redPentagon.size * Math.sin(i * angle - Math.PI / 2);
          i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fillStyle = gradientRed;
        ctx.globalAlpha = powerUpConfig.redPentagon.transparency;
        ctx.fill();
        ctx.restore();
      }

      if (activeBluePowerUp) {
        ctx.save();
        ctx.shadowColor = 'rgba(0, 0, 255, 0.5)';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        const gradientBlue = ctx.createLinearGradient(pentagon.x - powerUpConfig.bluePentagon.size, pentagon.y - powerUpConfig.bluePentagon.size, pentagon.x + powerUpConfig.bluePentagon.size, pentagon.y + powerUpConfig.bluePentagon.size);
        gradientBlue.addColorStop(0, 'darkblue');
        gradientBlue.addColorStop(1, 'blue');
        ctx.beginPath();
        const angle = (2 * Math.PI) / 5;
        for (let i = 0; i < 5; i++) {
          const px = pentagon.x + powerUpConfig.bluePentagon.size * Math.cos(i * angle - Math.PI / 2);
          const py = pentagon.y + powerUpConfig.bluePentagon.size * Math.sin(i * angle - Math.PI / 2);
          i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fillStyle = gradientBlue;
        ctx.globalAlpha = powerUpConfig.bluePentagon.transparency;
        ctx.fill();
        ctx.restore();
      }
    }

    function drawOrangeWave() {
      if (!orangeWaveActive) return;
      const now = performance.now();
      const elapsed = now - orangeWaveStartTime;
      let progress = elapsed / orangeWaveDuration;
      if (progress > 1) {
        progress = 1;
        orangeWaveActive = false;
        activeOrangePowerUp = false;
      }
      const currentSize = baseSize + (orangeWaveMaxSize - baseSize) * progress;
      const alpha = 1 - progress;
      ctx.save();
      ctx.shadowColor = 'rgba(255, 140, 0, 0.5)';
      ctx.shadowBlur = 15;
      ctx.globalAlpha = alpha;
      const gradientOrange = ctx.createLinearGradient(
        pentagon.x - currentSize,
        pentagon.y - currentSize,
        pentagon.x + currentSize,
        pentagon.y + currentSize
      );
      gradientOrange.addColorStop(0, 'darkorange');
      gradientOrange.addColorStop(1, 'orange');
      ctx.beginPath();
      const angle = (2 * Math.PI) / 5;
      for (let i = 0; i < 5; i++) {
        const px = pentagon.x + currentSize * Math.cos(i * angle - Math.PI / 2);
        const py = pentagon.y + currentSize * Math.sin(i * angle - Math.PI / 2);
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fillStyle = gradientOrange;
      ctx.fill();
      ctx.restore();
    }

    function updateOrangeWave() {
      if (!orangeWaveActive) return;
      const now = performance.now();
      const elapsed = now - orangeWaveStartTime;
      let progress = elapsed / orangeWaveDuration;
      if (progress > 1) {
        progress = 1;
        orangeWaveActive = false;
        activeOrangePowerUp = false;
      }
      const currentSize = baseSize + (orangeWaveMaxSize - baseSize) * progress;
      circles.forEach((circle) => {
        if (!orangeHitCircles.includes(circle) && isCircleInsideOrangeWave(circle, currentSize)) {
          circle.clicks -= orangeWaveDamage;
          if (circle.clicks <= 0) {
            if (circle.color === 'pink') {
              spawnAdjacentCircles(circle);
            }
            circle.destroy();
          }
          orangeHitCircles.push(circle);
        }
      });
    }

    function isCircleInsideOrangeWave(circle, currentSize) {
      const dist = Math.hypot(circle.x - pentagon.x, circle.y - pentagon.y);
      return dist < currentSize;
    }

    function animate() {
      if (isGameOver || isPaused) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (isDarkMode) {
        ctx.fillStyle = '#222';
      } else {
        ctx.fillStyle = '#fff';
      }
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawPowerUpPentagons();
      drawOrangeWave();
      pentagon.draw();
      circles.forEach((circle) => {
        circle.update();
        circle.draw();
      });
      particles.forEach((particle, index) => {
        particle.update();
        if (particle.life <= 0) {
          particles.splice(index, 1);
        } else {
          particle.draw();
        }
      });
      stains.forEach((stain, index) => {
        stain.update();
        if (stain.isExpired()) {
          stains.splice(index, 1);
        } else {
          stain.draw();
        }
      });
      stars.forEach((star) => {
        star.draw();
      });
      requestAnimationFrame(animate);
    }

    const initialLevel = difficultyLevels[0];
    currentSpawnInterval = initialLevel.interval;
    currentCirclesAtOnce = initialLevel.circlesAtOnce;
    spawnIntervalElement.textContent = currentSpawnInterval.toString();
    spawnIntervalId = setInterval(spawnCircles, currentSpawnInterval);
    starSpawnIntervalId = setInterval(spawnStar, powerUpConfig.starInterval * 1000);
    setInterval(updateInfo, 1000);
    animate();

    redPowerUpIntervalId = setInterval(() => {
      if (isGameOver || isPaused) return;
      if (activeRedPowerUp) {
        circles.forEach((circle) => {
          if (!circle.isGrayCircle && !circle.isBlackCircle && circle.clicks > 0) {
            const dist = Math.hypot(circle.x - pentagon.x, circle.y - pentagon.y);
            if (dist < powerUpConfig.redPentagon.size) {
              circle.clicks -= 1;
              circle.lastRedClickTime = gameTime;
              if (circle.clicks <= 0) {
                if (circle.color === 'pink') {
                  spawnAdjacentCircles(circle);
                }
                circle.destroy();
              }
            }
          }
        });
      }
      bolasEstouradasElement.textContent = ballsPopped.toString();
      pontuacaoElement.textContent = score.toString();
    }, 500);
  </script>
</body>
</html>
